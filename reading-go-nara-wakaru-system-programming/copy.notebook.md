# Goならわかるシステムプログラミング

**Golangではこのファイルディスクリプタの仕組みを模倣して、すべてのOSのAPIの差異を言語レベルで吸収している**
こうやってOSの差分を吸収してるんだなあとしみじみ
プライベートメソッドの中身がすでに例と変わっていて、どっかの本で不安定な実装はプライベートメソッドで隠蔽すると言ってたのを思い出した

# io.Writer
出力に共通する仕様を定義したインターフェース
`(r *receiver) Write(b byte[]) (n int, e err)`という感じ
**byte列の内容をreceiverに書き込む**
ファイルディスクリプタを模している

- osが持つシステムコールの相似形のインターフェース
- 例えば、File.Write()はsyscall.write() を呼び出してる
  - `syscall.write()`はファイルディスクリプタを引数に取る

たいていは書き込んだ内容は何らかの形で出力されうる
* Fileとして...
* 特定のメソッドを実行すると...

## ファイルディスクリプタ

OSがカーネルレイヤーでファイルを抽象化するために用意した仕組み。
ファイルを識別するための数値。この数値を指定してファイルアクセスすると、対応したファイルを扱える。
扱えるのはファイルだけではなく、「標準入出力、ソケット、OS、内蔵されてる乱数の仕組み、etc…」など本来ファイルでないものにも割り当てられて、ファイルと同じよう扱える
とはいえ、OSごとに仕様の差異があったりする…。
そのため、Golangではファイルディスクリプタのような抽象化を言語のレイヤーでおこなっている

## io.Writerの例
* os.File
ファイルを開くための構造体
os.Stdin、os.Stdoutやos.StderrはGoがファイルとして開いていた

* bytes.Buffer
書き込んだ内容をためておき（バッファリングして）、まとめて結果を受け取れる
あくまで、bytesを貯める構造体

* net.Conn / http.ResponseWriter

## io.Writerにデコレータもある
* io.MultiWriter
* gzip
* bufio.Writer
  * 出力結果を一時的にためて、ある程度の分量ごとにまとめて書き出す
  * `Flush()`によってio.Writerに書き出す
  * bytes.Bufferとは違って、いわゆるバッファ付き出力


## io.Writerに書き出す汎用関数もある
インターフェースなので当然ですが、このインターフェースを利用してio.Writerに内容を書き出す関数も存在します
io.Writerに書き込む関数はio.Writerの**参照**を受け取る必要がある（のでポインタ型を引数に取る）ため、アドレス(&)を引数に渡す
io.Writerでの`Write`実行は`(w *io.Writer) Write(...)`のため、基本的にポインタで利用される
（引数で渡すときには`&`をつけて、アドレス（参照）を持ち回す）
構造体で参照を利用する可能性がある場合は、基本的に&で渡す
Goはアドレスだろうと、実体だろうと`.`でメソッドが実行できる

# io.Reader
入力に共通するインターフェース
`(r *receiver) Read(p byte[]) (n int, e err)`という感じ
**receiverの内容を引数のp（バイト列）に書き込む**
この`p`のようなバイト列は`make()`を使って作ると良い
ex. `make([]byte, 1024)`

メモリ管理周りが面倒になることが多く、だいたいはReadのために定義された便利関数群を利用すると良い
ex. 
* ioutil.ReadAll(reader)
  * 終端記号になるまですべてを読み込んだバイト列を返してくれる
* io.ReadFull(reader, buffer)
  * 決まったバイト数だけを読み込み、読めない場合はエラーを返してくれる

